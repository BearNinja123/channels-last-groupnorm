FORWARD
T (threads per block) = 128 (or 256)
X = NHWC input -> N(HWd)gG where gG = T, dg = D
  strides: (HWD)G, gG, G, 1
N blocks, (x=G, y=g) threads per block
each block processes one sample in the batch
each thread processes HWd elements for one group

means, rstds = empty(N, 1, G)

# get stats
val = empty
for i in range(HWd)
  x = load X[bix*HWDG + i*gG + ty*G + tx]
  online_welford_reduce(val, x)
mean, rstd = get_stats(val)

#reduce a certain along the block y axis (reduction of g threads) based on a reduction function
fn y_reduce(val, reduction_fn, output_buffer)
  tid = ty * bdx + tx
  output_buffer[tid] = val

  # this part shouldn't have to be super optimized since it only reduces over N * T values
  for (stride = bdx*bdy/2; stride > bdx; stride >>= 1) # halving stride each iter
    if (tid < stride)
      tid_val = output_buffer[tid]
      tid2_val = output_buffer[tid + stride]
      output_buffer[tid] = reduction_fn(tid_val, tid2_val)
    __syncthreads()

__shared__ means_reduced[bdy, bdx]
__shared__ rstds_reduced[bdy, bdx]
y_reduce(mean, online_welford_reduce, means_reduced)
y_reduce(rstd, online_welford_reduce, rstds_reduced)

# assign final reduction in each block and group to output
if ty == 0
  means[bix*G + tx] = means_reduced[tx]
  rstds[bix*G + tx] = rstds_reduced[tx]

# normalize
(X - means)rstds * gammas + betas

BACKWARD (NCHW)
G = num groups
D = dim per group
n = blockIdx.x # element idx
g = blockIdx.y # group idx
ng = n * G + g # [bix][biy], element-group idx
sum1 = sum2 = 0
for (i = tx; i < D; i += bdx)
  index = ng * D + i # [bix][biy][tx]
  c = g * D + i # [biy][tx]
  gamma_v = 1 if gamma is None else gamma[c]
  sum1 += dY[index] * X[index] * gamma_v # sum1 = gamma*X @ dY AKA sum(X * (gamma @ dy))
  sum2 += dY[index] * gamma_v # sum2 = gamma @ dY
 
sum1 = sum over threads(sum1)
sum2 = sum over threads(sum2)

# c1, c2, c3, c4 are coeffs for each element-group
if ty == 0
  x = (sum2 * mean[ng] - sum1) * rstd[ng]^3 / D; # AKA -sum(norm(X[ng])[i] * (gamma[g] * dy[ngi]), i) / std[ng]^2 / D
  c2[ng] = x;
  c3[ng] = -x * mean[ng]; # AKA sum(norm(X[ngi]) * gamma[g] * dy[ngi] * mean[ng], i)
  c4[ng] = -sum2 * rstd[ng] / D; # AKA -gamma * sum(dy) / std[ng] / D

c1 = rstd * gamma 
dx = c1*dy + (c2*x + c3) + c4 # sum in paren = -gamma[g] / D / std[ng] * sum(norm(x[ng])[i], i) * norm(x[ng])

BACKWARD (NHWC)
sum1_buffer, sum2_buffer = empty(N, G, 1)
G = num groups
D = dim per group
n = bix # element idx
g_idx = tx # group idx
ng = n * G + g_idx # element-group idx
sum1 = sum2 = 0
for i in range(HWd)
  index = n * HWDG + i * gG + ty * G + tx # [bix][i][ty][tx]
  gamma_v = 1 if gamma is None else gamma[ng]
  sum1 += dY[index] * X[index] * gamma_v # sum1 = sum(X * gamma * dy)
  sum2 += dY[index] * gamma_v # sum2 = sum(gamma * dY)
 
__shared__ reduced_sum1[bdx][bdy]
__shared__ reduced_sum2[bdx][bdy]
y_reduce(sum1, sum, reduced_sum1)
y_reduce(sum2, sum, reduced_sum2)

if ty == 0
  sum1, sum2 = reduced_sum1[tx], reduced_sum2[tx]
  sum1_buffer[ng] = sum1
  sum2_buffer[ng] = sum2

# c1, c2, c3, c4 are coeffs for each element-group
if tx == 0
  x = (sum2 * mean[ng] - sum1) * rstd[ng]^3 / D; # AKA -sum(norm(X[ng])[i] * gamma[g] * dy[ngi], i) / std[ng]^2 / D
  c2[ng] = x;
  c3[ng] = -x * mean[ng]; # AKA sum(norm(X[ngi]) * gamma[g] * dy[ngi] * mean[ng], i)
  c4[ng] = -sum2 * rstd[ng] / D; # AKA -gamma * sum(dy) / std[ng] / D

c1 = rstd * gamma 
dx = c1*dy + (c2*x + c3) + c4 # sum in paren = -gamma[g] / D / std[ng] * sum(norm(x[ng])[i], i) * norm(x[ng])
